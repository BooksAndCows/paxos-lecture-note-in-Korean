# Basic Paxos

## 1. 필요한 요구사항들 \(Requirements for Basic Paxos\)

알고리즘의 안전성\(safety\)과 liveness에 대한 두 가지 전반적인 요구 사항이 있다. 안전성의 일반적인 의미는 알고리즘이 정상적으로 동작한다는 걸 의미한다. 예상과 다르게 또는 의도치 않게 알고리즘이 동작할 일은 없다는 의미이며 basic Paxos 알고리즘은 반드시 하나의 값을 선택해야 한다는 것을 의미한다.

> there are two overall requirements for the algorithm safety and liveness. safety means in general terms that algorithm must never do anything bad and so for basic Paxos that means we must choose at most one value.

첫번째 값을 대체하는 두번째 값을 뽑는 등의 작업은 절대 해선 안된다. 안전성에 대한 또다른 요구 사항은 만약 서버가 값이 채택되어졌다고 믿는다면, 그 값은 정말로 서버가 속한 클러스터\(cluster\)로부터 선택되었다는 것이다.

반드시 하나의 값을 선택한다는 점, 그리고 서버가 해당 값이 채택되어졌다고 믿는다면 서버 클러스터로부터 정말 채택되어진 것이라는 점, 이 두가지가 안전\(safety\)에 대한 특징이다.

![](/assets/2.PNG)

liveness\(대상이 살아있음을 확인하는\) 속성은 우리가 시스템이 결국 잘 작동할 것을 원한다는 걸 말해준다. 단순히 안좋은 일이 일어나진 않겠지라고 기대하는 것이 아니라 반드시 잘 작동해야한다.

basic Paxos에는 두 가지의 liveness 속성이 존재한다. 첫번째로 우리는 값을 반드시 선택해야 한다는 점이다. 두번째는 서버들은 선택된 값을 찾을 수 있다는 점이다.

이러한 liveness 특징들은 다수의 서버가 정상작동하는 한 충분히 빠르고 합리적으로  통신이 가능하다는 일반적인 합의 개념하에 유지되어야 한다. 이러한 조건하에 클러스터는 살아 있어야 한다. 그래야 값을 결정하고 클러스터 구성원 모두가 그 값을 알게할 수 있기 때문이다.

> now these liveness properties have to hold under the general consensus notion that is as long as a majority of servers are running and as long as they can communicate with each other reasonably quickly.
>
> then under these conditions the cluster should be live that is it will eventually choose a value and everybody will find out about it.

basic Paxos를 구현하기 위해 상호작용하는 두 개의 구성요소가 있다. 바로 제안자\(proposers\)들과 수용자\(acceptor\)들이다. 제안자는 활동하는\(깨어있는\) 구성원으로 제안자는 주로 클라이언트에게 요청을 받고 클라이언트가 요청한 특정 값이 선택되어질 수 있도록 도움을 준다. 도움을 준다는 건, 클라이언트가 요청한 값을 자신의 의견으로 내서 클러스터의 구성원들\(서버들\)이 그 값에 동의하도록 시도한다.

> Proposers are the active elements that is they're actually trying to do something.
>
> They will typically receive requests from clients asking that particular values be chosen and then they will try and put those values forth and get everybody in the cluster to agree to them.

수용자는 수동적인 구성원이다. 수용자들의 역할은 단순히 제안자가 요청한 것에 대한 응답을 해주는 것이다. 수용자들의 응답 하나 하나는 일종의 표로 작용되어서 투표에 반영이 된다. 제안자들은 각각 자신이 제안한 값이 채택되어지기를 바라기 때문에 클러스터에 존재하는 다수의 수용자들로부터 표\(수락\)를 얻고 싶을 것이다.

> acceptors are passive elements. they simply respond to requests that  come from proposers.
>
> you can think of their responses as votes where a proposer is trying to get a majority of votes from the acceptors in the cluster.

수용자들은 결정 프로세스에 대한 상태 정보 중 여러가지를 저장한다. 예를 들면 채택되거나 되지 않은 값들을 저장하거나 그들이 던진 표\(즉 수용자가 선택한 값\)을 저장한다. 투표로 비유하자면, 어떤 후보들이 나왔고 본인이 어떤 후보에 투표했는지 등을 알고 있다고 할 수 있다. 또한 수용자들은 어떤 값이 채택됐는지\(어떤 후보가 당선됐는지\)에 대해 알고 싶어한다.

![](/assets/3.PNG)

우리가 처음에 알 수 있듯이, 제안자들만이 값이 선택되었다는 것을 알 수 있지만 우리는 수용자들도 결국 이 값을 찾아내길 원한다. 그 값을 수용자가 상태 머신에 실행을 위해 반영하게 하기 위해서 수용자는 결국 그 값을 알아낼 수 있어야 한다.

사실 전통적인 Lamport 방식에서는 리스너\(Listener\)라고 불리는 세번째 구성원도 있지만, 이 강의에서는 우린 리스너와 수용자를 한 번에 묶어낸 개념으로 설명한다. 별도로 구분하지 않겠다는 뜻이다. 또한 이 강의에서 우리는 서버는 각각 한 명의 제안자와 한 명의 수용자를 함께 포함하고 있는 것으로 가정한다. Paxos를 구현할 때 각 서버를 한 명의 구성원의 역할만 하게끔 구현할 수도 있지만 이 강의에서는 하나의 서버가 한 명의 제안자가 될 수도, 수용자가 될 수도 있는 구조로 설명한다.

## 2. 팍소스를 구현할 때 해결해야 할 문제점

### 2.1. 단 하나의 Acceptor를 두었을 때의 문제점

지금부터 보여주는 몇가지 상황은 우리가 합의\(컨센서스\)를 제대로 설계하기 위해 꼭 해결해야만 하는 문제점들이다. 아래의 첫번째 템플릿을 살펴보자. 문제점이 발생하는 상황에 대한 템플릿이다.

![](/assets/4.PNG)

위 템플릿은 우리가 단 하나의 수용자를 뒀을 때 발생할 수 있는 문제점을 다룬다. 단 한 명의 수용자에게 우리는 모든 제안자가 자신의 값을 택해달라고 보내는 요청들을 처리하라고 시켰다고 가정해보자. \(혹사 시킨다는 생각이 물씬 든다.. 이러다가 파업이라도 하면 어떻게 될런지..\)

아마도 수용자는 하나의 값을 선택해서 그 값을 채택되었다고 처리할 것이다. \(위 템플릿에서는 jmp 명령어를 채택했다.\) 매우 간단하네! 라고 생각할 수 있지만 그 단 한 명의 수용자가 만약 다운되거나 제기능을 못할 때를 처리하지 못하는 설계다.

만약 이 수용자에게 이상이 생긴다면, 우리는 어떤 값이 선택되었는지 알 수 없다. 수용자가 살아날 때까지 기다릴 수밖에 없다.

> if the acceptor crashes right after choosing, we have no way of knowing which value was chosen and so we'd have to wait for that acceptor restart.

우리가 구현하고자 하는 시스템의 목표는 대다수의 서버\(노드\)만으로 완벽한 서비스를 차질 없이 제공하는 것이기 때문에 첫번째 문제점에 나타난 것처럼 하나의 수용자만 두는 설계는 올바르지 않다. 이러한 문제점을 개선하기 위해 우리는 일종의 정족수\(quorum\)개념을 도입한다. 합의를 위해 모인 의사구성원들이 의결을 하는데 필요한 최소한도의 인원수를 지정하는 것이다.

### 2.1.1 단 하나의 Acceptor를 둠으로써 발생하는 문제의 해결

정족수는 보통 3, 5 또는 7과 같이 적은 숫자의 홀수만큼의 수용자들로 구성한다. 이렇게 하면 한 명의 수용자가 망가져도, 대다수의 수용자가 제기능을 할 수 있기 때문에 값을 채택하는 매커니즘은 여전히 정상작동할 수 있다.

만약 값을 수용한 수용자가 그 즉시 바로 다운되는 경우에는 다른 수용자들이 그 수용자가 어떤 값을 택했는지 확인하고 처리할 수 있기 때문에 이 정족수의 개념은 굉장히 유용하다. 하지만 정족수 개념을 도입해도 아직 해결해야할 과제들이 남아있다. 아래의 템플릿을 살펴보자.

![](/assets/5.PNG)

만약 수용자가 자신이 첫번째로 받은 값만 수용한다고 가정해보자. S1\(1번 서버\)은 클라이언트가 보낸 red라는 정보를 수용했다. 그리고 자신이 수용한 값이 채택되는 걸 원하기에 다른 서버에게 전파하는 작업을 진행한다. 그와 거의 동시에 S3와 S5도 클라이언트로부터 요청을 받는다. 각각 blue와 green이 채택되게 도와달라고 부탁을 받은 상태고, 이 값들이 채택될 수 있게 S3와 S5도 전파작업을 진행한다.

이렇게 동시다발적으로 이루어진 결과, S1은 S1과 S2의 동의를 얻었고 S3는 S3와 S4의 동의를 얻었다. S5는 자신 빼고는 아무도 없다. 결국 다수결로 의사결정을 진행하지 못하게 되는 상태에 빠졌다. 3명의 찬성을 얻은 안건이 있어야 통과가 되는데 어느 누구도 3개의 표를 얻지 못했다. 이 결과가 시사하는 점은 수용자는 때때로 자신이 투표했던 것을 포기하고 다른 값\(후보\)에 투표해야한다.

이러한 점이 시사하는 건 단 한 번의 라운드\(round\)으로는 어떤 값이 채택되는 일이 굉장히 어렵다는 것이다. 2라운드, 어쩌면 3라운드 정도까지 선출 작업을 반복해야 할지도 모른다. 따라서 우리는 이제 두 개의 말을 구분지으려 한다. 채택되었다\(chosen\)와 수용되었다\(accepted\) 이 두 말을 구분해야 한다.

채택되었다는 건 정말 한 클러스터 안에서 그 값이 채택되서 받아들여진다는 의미이고, 수용되었다는 건 클라이언트가 보낸 값을 수용자가 받아놨긴 한데 아직 이 값이 클러스터에서 채택\(선출 혹은 당선\)되지 않았다는 의미다. 채택\(chosen\)이 되려면 클러스터\(그룹\) 안의 대다수 서버에게 수용되어져야 한다.

### 2.2 좀 더 복잡한 문제

이번엔 좀 더 난잡한 문제를 생각해보자.  수용자가 자신에게 온 값이 뭐든 그냥 다 받아들이는\(accepted\) 상황을 생각하자. 이런 상황에서 발생할 수 있는 두 가지 문제점이 있다. 첫번째는 여러 개의 값이 채택되어질 수 있다는 것이다. 아래의 템플릿을 살펴보자.

> first problem is that we could end up choosing multiple values.

![](/assets/6.PNG)

S1이 클라이언트가 요청한 red가 채택되어지기를 바라면서 red를 제안한다. S1은 다른 서버들에게 자신의 값을 수용\(accept\)해줄 것을 요청한다. 그 결과 S2, S3가 red를 받아들여 red가 채택\(chosen\)되었다. 5명 중 3명이 동의했으니 다수결의 원칙에 의해 Red는 채택될 수 있다.

채택되어진 후, 클라이언트는 S5에 blue를 의뢰했다. S5는 blue가 채택되기를 바라며 다른 서버들에게 수용\(accept\)해줄 것을 요청한다. 우리가 가정한 문제상황에 따르면 수용자는 어떤 값이든 계속해서 수용한다고 했으니 이미 red를 수용했던 S3는 blue를 수용할 수 있다. 이렇게 S3, S4 그리고 S5가 blue를 채택하게 되면서 Blue는 채택\(chosen\)되게 된다.

이렇게 되면 우리가 설계하고자 했던 시스템의 기본 원칙이 무너지게 되는데, 단 하나의 값만을 채택해야 한다는 원칙을 위 상황은 위반하게 된다. 따라서 뭔가 해결책이 필요하다. 어떻게 해결할 수 있을까?

템플릿 아래에도 적혀 있지만 위 템플릿에서 S5가 클라이언트로부터 받은 값 blue를 주장하기 전에! 그 전에 채택\(chosen\)되어져 있던 값이 있는지 체크하는 것이다. 만약 채택된 값이 있었다면 S5는 자신이 받은 값 blue를 제안하는 것이 아니라 이미 채택된 값 red를 제안하게 하는 것이다. 자신이 기존에 가지고 있던 값은 포기한다.

이렇게 되면 위 템플릿에서 S5가 새롭게 주장한 값인 red는 S3, S4에게로 전파되고 또 다시 채택되게 된다. 이것을 우리는 \(2-phase protocol\)이라고 칭한다.  하지만 안타깝게도 이 또한 문제를 해결하기엔 충분치 않다. 아래의 템플릿을 살펴보자.

![](/assets/7.PNG)

S1은 red를 제안하려 한다. 그렇지만 2-phase protocol을 적용해서 그 전에 먼저 채택된 값\(chosen value\)이 있는지 확인한다. 하지만 S1이 red를 제안하던 때에는 \(수직으로 아래까지 선을 이으면 S1과 동시대에 발생한 이벤트는 없음\) 어떠한 서버\(S\*\)도 값을 수용하고 있지 않았으므로 S1은 red를 클러스터의 각 서버들에게 전송하기 시작한다.

하지만 아직까지 어떤 수용자도 S1의 요청에 반응하지 않고 있는 이때! S5가 클라이언트로부터 요청 받은 blue값을 제안하기 시작한다. 물론 S5도 제안하기 전에 어떤 값이 수용되어 있는지 확인을 한다. S1도 이 당시에 아직 자신이 제안한 값을 accept하지 않았던 때이기에 S5도 이상없이 각 서버들에게 자신의 제안을 전파한다.

그리고 전파된 blue값이 먼저 채택\(chosen\)되어지는 상황이 발생했다. 하지만 이러는 동안에도 S1은 계속 동작하고 있었고 각 서버는 들어오는 값들을 수용할 수 있기에 또 하나의 채택된 값이 탄생한다. 이렇게 되면 단 하나의 값만 채택되야 한다는 기본 설계원칙을 또다시 어기게 된다.

이 문제를 해결하기 위해 일단 어떤 값이 채택되어졌다면 그 이후 제안되는 것들의 값은 버려야 한다. 위 템플릿에서 S3를 살펴보면, 이미 blue를 채택했기 때문에 이후에 제안이 들어온 red를 거부해야 한다. 이러한 절차를 위해 우리는 순서 개념을 도입한다. 채택된 값이 있다면 오래된 값을 버리는 규칙을 적용해보자. S1이 red를 수용할 때는 blue가 채택되기 이전의 시간이다. 즉 채택된 값 blue가 있을 때를 기준으로 S1이 제안한 red는 오래된 것이므로 S1은 red값을 버려야한다.

즉 우리는 2-phase protocol에서 공부했던 원칙\(제안하기 전에 채택된 값이 있는지 확인!\)과 더불어 각 제안들에 순서를 매겨야 한다는 것을 알게된 것이다.

### 2.2.1 좀 더 복잡한 문제를 해결하기 위해 필요한 개념

제안들에 순서를 매기는 방법에 대해 생각해보자. 단순하게 생각할 수 있는 건 각 제안에 고유한 번호를 부여하는 것을 생각해볼 수 있다\(이전의 제안에 있던 값을 다시 쓰는 등의 방법은 허용되지 않는다.\). 그리고 높은 번호가 낮은 번호보다 우선순위를 갖는다는 규칙을 함께 적용한다.

이러한 규칙을 적용한다면 각 서버가 프로토콜을 실행할 때 \(규칙을 따라 실행할 때\) 서버가 제안하는 제안의 번호는 고유한 값이어야 함은 물론이고 예전에 사용되었던 번호 혹은 자신이 발견했던 번호보다 커야한다. 높은 번호가 우선순위가 있다고 했는데 굳이 서버가 낮은 번호를 쓴다면 자신의 제안이 영영 받아들여지지 않을  것이기에 서버는 높은 번호를 사용할 것이다.

![](/assets/8.PNG)

이것을 구현하기 위해 고안된 방법은 두 값\(value\)을 결합하는 것이다. 위 템플릿의 제안 번호\(Proposal Number\)를 구성하고 있는 Server ID를 살펴보자. 모든 서버에게 고유한 식별자를 부여하고 이 고유한 서버 아이디를 제안 번호의 낮은 비트 순서에 둔다. \(낮은 비트 순서란 어려운 것이 아니다. 1100 이라는 비트가 있다면 00 파트에 해당하는 것이 낮은 비트 순서에 속한다.\)

이렇게 서버 고유 아이디 값을 줌으로써 다른 서버들이 이 아이디를 사용하지 않을 거라는 점을 보장할 수 있고 또한 이 값이 생성되기 전 다른 어떤 서버에서도 이전에 생성한 적이 없었다는 점 또한 보장할 수 있다. \(고유함을 보장한다고 보면 된다.\)

> first start with server Id.
>
> give every server a unique identifier and put that in the low-order bits of the proposal number so that guarantees that now no other server will ever generate this proposal or could have generated it before.

그 다음 우리는 높은 비트 순서에 라운드 번호\(Round Number\)를 둔다. 이 라운드 번호는 시간이 지나면 지날수록 게속 증가하면서 모든 서버에게 공유된다. 이 라운드 번호는 제안을 생성하거나 시도할 때 사용될 것이고 이 번호는 계속해서 커지기에 가장 최신의 제안일 수록 가장 큰 값일 것이고 고유한 번호일 것이다.

라운드 번호가 이렇게 작동하려면 서버는 자신에게 들어온 메시지\(제안\) 혹은 자신이 낸 제안 속에 있는 라운드 번호를 계속 주시하고 있어야 한다. 그리고 이렇게 살펴본 후에 서버는 가장 큰 라운드 번호를 저장하고 있는데, 이것을 우리는 최대라운드값\(maxRound\)라고 한다.

따라서 새로운 제안 번호를 생성하는건 단지 라운드 번호를 증가시키고 서버 아이디와 결합하는 것이다. 이러한 작업을 위해서 각 제안자는 가장 최신인 최대라운드\(maxRound\)값을 저장하고 자신의 하드디스크 혹은 다른 안정적인 저장장치에 기록해야 한다. 그래야 후에 각 서버에 이상\(혹은 충돌\)이 생겼을 때 정상적인 복구가 가능해지고 이전에 사용되었던 제안번호를 사용하지 않는다는 원칙도 지킬 수 있기 때문이다.

> to generate a new number, it simply increments that value and then concatenates it with its server ID.
>
> in order for this to work, the proposers must make sure they save the latest value of maxRound that they've used on disk or some other stable medium so that it can be recovered after a crash.
>
> this is needed to make sure that we don't accidentally reuse a proposal number if we crash and then restart.



## 팍소스 중간 정리

![](/assets/9.PNG)

앞서 설명했듯 우리는 2-phase approach를 사용해야만 한다. 첫번째 phase에서는 제안자가 자신이 제안한 값이 채택되어지기를 바라며 각 서버에게 값을 전송하려할 때, 모든 서버에게 RPC\(remote procedure call\)를 보낸다. RPC를 잘 모른다면 강의에 사용된 영어단어 및 개념 목록을 참조하자.

